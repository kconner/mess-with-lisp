(define (mul-interval x y)
  (define (find-signs z)
    (cond ((< (upper-bound z) 0) 'negative)
          ((< (lower-bound z) 0 (upper-bound z)) 'both)
          ((< 0 (lower-bound z)) 'positive)))
  (let ((xsigns (find-signs x))
        (ysigns (find-signs y)))
    (cond ((and (= xsigns 'negative) (= ysigns 'negative))
           (make-interval (* (upper-bound x) (upper-bound y))
                          (* (lower-bound x) (lower-bound y)))
          ((and (= xsigns 'negative) (= ysigns 'both))
           (make-interval (* …) (* …)))
          ((and (= xsigns 'negative) (= ysigns 'positive))
           (make-interval (* (lower-bound x) (upper-bound y))
                          (* (upper-bound x) (lower-bound y)))
          ((and (= xsigns 'both) (= ysigns 'negative))
           (make-interval (* …) (* …)))
          ((and (= xsigns 'both) (= ysigns 'both))
           (make-interval (* …) (* …))) ; the special case
          ((and (= xsigns 'both) (= ysigns 'positive))
           (make-interval (* …) (* …)))
           (make-interval (* (lower-bound x) (upper-bound y))
                          (* (upper-bound x) (upper-bound y)))
          ((and (= xsigns 'positive) (= ysigns 'negative))
           (make-interval (* (upper-bound x) (lower-bound y))
                          (* (lower-bound x) (upper-bound y)))
          ((and (= xsigns 'positive) (= ysigns 'both))
           (make-interval (* (upper-bound x) (lower-bound y))
                          (* (upper-bound x) (upper-bound y)))
          ((and (= xsigns 'positive) (= ysigns 'positive))
           (make-interval (* (lower-bound x) (lower-bound y))
                          (* (upper-bound x) (upper-bound y)))

; You get the idea.
